{"ast":null,"code":"let speechRecognition;\nlet listening = false;\nlet pendingInterrupt = null;\nexport function initSpeechRecognition(onTranscript) {\n  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n  if (!SpeechRecognition) {\n    console.error(\"Speech Recognition not supported\");\n    return null;\n  }\n  if (!speechRecognition) {\n    speechRecognition = new SpeechRecognition();\n    speechRecognition.continuous = true;\n    speechRecognition.interimResults = true;\n    speechRecognition.lang = 'en-US';\n    speechRecognition.onresult = event => {\n      const transcript = Array.from(event.results).map(result => result[0].transcript).join('');\n      const isFinal = event.results[event.results.length - 1].isFinal;\n\n      // ✅ Handle pending interrupt (after speech stopped)\n      if (pendingInterrupt) {\n        onTranscript(transcript.trim(), true);\n        pendingInterrupt = null;\n        return;\n      }\n\n      // ✅ If user starts talking during bot's speech\n      if (!isFinal && window.speechSynthesis.speaking) {\n        window.speechSynthesis.cancel(); // Stop current bot speech\n        pendingInterrupt = true; // Defer processing until speech ends\n        return;\n      }\n\n      // ✅ Normal case\n      if (onTranscript && transcript.trim()) {\n        onTranscript(transcript.trim(), isFinal);\n      }\n    };\n    speechRecognition.onerror = e => {\n      console.error('SpeechRecognition Error:', e);\n      if (e.error === 'no-speech' || e.error === 'audio-capture' || e.error === 'network') {\n        listening = false;\n        setTimeout(() => {\n          startListening(onTranscript);\n        }, 1000); // auto-retry\n      }\n    };\n    speechRecognition.onend = () => {\n      if (listening) {\n        // Mic ended unexpectedly → restart\n        console.warn('Mic stopped unexpectedly. Restarting...');\n        startListening(onTranscript);\n      }\n    };\n  }\n  return speechRecognition;\n}\nexport function startListening(onTranscript) {\n  const recognition = initSpeechRecognition(onTranscript);\n  if (!recognition || listening) return;\n  try {\n    recognition.start();\n    listening = true;\n  } catch (err) {\n    console.warn('Mic start failed or already running:', err);\n  }\n}\nexport function stopListening() {\n  if (speechRecognition && listening) {\n    speechRecognition.stop();\n    listening = false;\n  }\n}\nexport function speakWithAudioFeedback(text, setVolume, onEnd) {\n  const synth = window.speechSynthesis;\n  if (!synth) return;\n  synth.cancel(); // cancel any current speech\n\n  const utter = new SpeechSynthesisUtterance(text);\n  utter.lang = 'en-US';\n  let volInterval;\n  utter.onstart = () => {\n    volInterval = setInterval(() => {\n      const fakeVol = Math.random(); // simulate volume bar\n      setVolume(fakeVol);\n    }, 100);\n  };\n  utter.onend = () => {\n    clearInterval(volInterval);\n    setVolume(0);\n    if (onEnd) onEnd();\n  };\n  utter.onerror = () => {\n    clearInterval(volInterval);\n    setVolume(0);\n    if (onEnd) onEnd();\n  };\n  try {\n    synth.speak(utter);\n  } catch (err) {\n    console.error('SpeechSynthesis failed:', err);\n    if (onEnd) onEnd();\n  }\n}\nexport function stopSpeaking() {\n  if (window.speechSynthesis && window.speechSynthesis.speaking) {\n    window.speechSynthesis.cancel();\n  }\n}","map":{"version":3,"names":["speechRecognition","listening","pendingInterrupt","initSpeechRecognition","onTranscript","SpeechRecognition","window","webkitSpeechRecognition","console","error","continuous","interimResults","lang","onresult","event","transcript","Array","from","results","map","result","join","isFinal","length","trim","speechSynthesis","speaking","cancel","onerror","e","setTimeout","startListening","onend","warn","recognition","start","err","stopListening","stop","speakWithAudioFeedback","text","setVolume","onEnd","synth","utter","SpeechSynthesisUtterance","volInterval","onstart","setInterval","fakeVol","Math","random","clearInterval","speak","stopSpeaking"],"sources":["H:/camera/project_root/frontend/src/utils/voice.js"],"sourcesContent":["let speechRecognition;\r\nlet listening = false;\r\nlet pendingInterrupt = null;\r\n\r\nexport function initSpeechRecognition(onTranscript) {\r\n  const SpeechRecognition =\r\n    window.SpeechRecognition || window.webkitSpeechRecognition;\r\n\r\n  if (!SpeechRecognition) {\r\n    console.error(\"Speech Recognition not supported\");\r\n    return null;\r\n  }\r\n\r\n  if (!speechRecognition) {\r\n    speechRecognition = new SpeechRecognition();\r\n    speechRecognition.continuous = true;\r\n    speechRecognition.interimResults = true;\r\n    speechRecognition.lang = 'en-US';\r\n\r\n    speechRecognition.onresult = (event) => {\r\n      const transcript = Array.from(event.results)\r\n        .map(result => result[0].transcript)\r\n        .join('');\r\n      const isFinal = event.results[event.results.length - 1].isFinal;\r\n\r\n      // ✅ Handle pending interrupt (after speech stopped)\r\n      if (pendingInterrupt) {\r\n        onTranscript(transcript.trim(), true);\r\n        pendingInterrupt = null;\r\n        return;\r\n      }\r\n\r\n      // ✅ If user starts talking during bot's speech\r\n      if (!isFinal && window.speechSynthesis.speaking) {\r\n        window.speechSynthesis.cancel(); // Stop current bot speech\r\n        pendingInterrupt = true;         // Defer processing until speech ends\r\n        return;\r\n      }\r\n\r\n      // ✅ Normal case\r\n      if (onTranscript && transcript.trim()) {\r\n        onTranscript(transcript.trim(), isFinal);\r\n      }\r\n    };\r\n\r\n    speechRecognition.onerror = (e) => {\r\n      console.error('SpeechRecognition Error:', e);\r\n\r\n      if (\r\n        e.error === 'no-speech' ||\r\n        e.error === 'audio-capture' ||\r\n        e.error === 'network'\r\n      ) {\r\n        listening = false;\r\n        setTimeout(() => {\r\n          startListening(onTranscript);\r\n        }, 1000); // auto-retry\r\n      }\r\n    };\r\n\r\n    speechRecognition.onend = () => {\r\n      if (listening) {\r\n        // Mic ended unexpectedly → restart\r\n        console.warn('Mic stopped unexpectedly. Restarting...');\r\n        startListening(onTranscript);\r\n      }\r\n    };\r\n  }\r\n\r\n  return speechRecognition;\r\n}\r\n\r\nexport function startListening(onTranscript) {\r\n  const recognition = initSpeechRecognition(onTranscript);\r\n  if (!recognition || listening) return;\r\n\r\n  try {\r\n    recognition.start();\r\n    listening = true;\r\n  } catch (err) {\r\n    console.warn('Mic start failed or already running:', err);\r\n  }\r\n}\r\n\r\nexport function stopListening() {\r\n  if (speechRecognition && listening) {\r\n    speechRecognition.stop();\r\n    listening = false;\r\n  }\r\n}\r\n\r\nexport function speakWithAudioFeedback(text, setVolume, onEnd) {\r\n  const synth = window.speechSynthesis;\r\n  if (!synth) return;\r\n\r\n  synth.cancel(); // cancel any current speech\r\n\r\n  const utter = new SpeechSynthesisUtterance(text);\r\n  utter.lang = 'en-US';\r\n\r\n  let volInterval;\r\n\r\n  utter.onstart = () => {\r\n    volInterval = setInterval(() => {\r\n      const fakeVol = Math.random(); // simulate volume bar\r\n      setVolume(fakeVol);\r\n    }, 100);\r\n  };\r\n\r\n  utter.onend = () => {\r\n    clearInterval(volInterval);\r\n    setVolume(0);\r\n    if (onEnd) onEnd();\r\n  };\r\n\r\n  utter.onerror = () => {\r\n    clearInterval(volInterval);\r\n    setVolume(0);\r\n    if (onEnd) onEnd();\r\n  };\r\n\r\n  try {\r\n    synth.speak(utter);\r\n  } catch (err) {\r\n    console.error('SpeechSynthesis failed:', err);\r\n    if (onEnd) onEnd();\r\n  }\r\n}\r\n\r\nexport function stopSpeaking() {\r\n  if (window.speechSynthesis && window.speechSynthesis.speaking) {\r\n    window.speechSynthesis.cancel();\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}