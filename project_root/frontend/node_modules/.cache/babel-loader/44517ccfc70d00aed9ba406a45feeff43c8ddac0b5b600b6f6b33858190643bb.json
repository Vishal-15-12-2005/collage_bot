{"ast":null,"code":"let speechRecognition;\nlet listening = false;\nlet shouldAlwaysListen = true; // üîÅ Flag to keep mic always on\nlet pendingInterrupt = null;\nexport function initSpeechRecognition(onTranscript) {\n  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n  if (!SpeechRecognition) {\n    console.error(\"Speech Recognition not supported\");\n    return null;\n  }\n  if (!speechRecognition) {\n    speechRecognition = new SpeechRecognition();\n    speechRecognition.continuous = true;\n    speechRecognition.interimResults = true;\n    speechRecognition.lang = 'en-US';\n    speechRecognition.onresult = event => {\n      const transcript = Array.from(event.results).map(result => result[0].transcript).join('');\n      const isFinal = event.results[event.results.length - 1].isFinal;\n\n      // üß† If user interrupts the bot while it's talking\n      if (!isFinal && window.speechSynthesis.speaking) {\n        window.speechSynthesis.cancel(); // stop current speech\n        if (onTranscript && transcript.trim()) {\n          onTranscript(transcript.trim(), true); // treat as final\n        }\n        return;\n      }\n      if (onTranscript && transcript.trim()) {\n        onTranscript(transcript.trim(), isFinal);\n      }\n    };\n    speechRecognition.onerror = e => {\n      console.error('SpeechRecognition Error:', e);\n      listening = false;\n      // üîÅ Restart on common mic failures\n      if (shouldAlwaysListen) {\n        setTimeout(() => startListening(onTranscript), 1000);\n      }\n    };\n    speechRecognition.onend = () => {\n      listening = false;\n      // üîÅ Restart on end (natural or forced)\n      if (shouldAlwaysListen) {\n        console.warn('SpeechRecognition ended. Restarting...');\n        setTimeout(() => startListening(onTranscript), 100);\n      }\n    };\n  }\n  return speechRecognition;\n}\nexport function startListening(onTranscript) {\n  const recognition = initSpeechRecognition(onTranscript);\n  if (!recognition || listening) return;\n  try {\n    recognition.start();\n    listening = true;\n    console.log('üéôÔ∏è Mic started');\n  } catch (err) {\n    console.warn('Mic start failed or already listening:', err);\n  }\n}\nexport function stopListening() {\n  shouldAlwaysListen = false; // Prevent auto-restart\n  if (speechRecognition && listening) {\n    speechRecognition.stop();\n    listening = false;\n    console.log('üõë Mic stopped manually');\n  }\n}\nexport function speakWithAudioFeedback(text, setVolume, onEnd, onTranscript) {\n  const synth = window.speechSynthesis;\n  if (!synth) return;\n  synth.cancel(); // cancel any previous voice\n\n  const utter = new SpeechSynthesisUtterance(text);\n  utter.lang = 'en-US';\n  let volInterval;\n  utter.onstart = () => {\n    volInterval = setInterval(() => {\n      const fakeVol = Math.random(); // Simulated volume bar\n      setVolume(fakeVol);\n    }, 100);\n  };\n  utter.onend = () => {\n    clearInterval(volInterval);\n    setVolume(0);\n\n    // üîÅ Always restart mic after speech ends\n    if (shouldAlwaysListen && onTranscript) {\n      startListening(onTranscript);\n    }\n    if (onEnd) onEnd();\n  };\n  utter.onerror = () => {\n    clearInterval(volInterval);\n    setVolume(0);\n\n    // üîÅ Restart listening on error too\n    if (shouldAlwaysListen && onTranscript) {\n      startListening(onTranscript);\n    }\n    if (onEnd) onEnd();\n  };\n  synth.speak(utter);\n}\nexport function stopSpeaking() {\n  if (window.speechSynthesis && window.speechSynthesis.speaking) {\n    window.speechSynthesis.cancel();\n  }\n}","map":{"version":3,"names":["speechRecognition","listening","shouldAlwaysListen","pendingInterrupt","initSpeechRecognition","onTranscript","SpeechRecognition","window","webkitSpeechRecognition","console","error","continuous","interimResults","lang","onresult","event","transcript","Array","from","results","map","result","join","isFinal","length","speechSynthesis","speaking","cancel","trim","onerror","e","setTimeout","startListening","onend","warn","recognition","start","log","err","stopListening","stop","speakWithAudioFeedback","text","setVolume","onEnd","synth","utter","SpeechSynthesisUtterance","volInterval","onstart","setInterval","fakeVol","Math","random","clearInterval","speak","stopSpeaking"],"sources":["H:/camera/project_root/frontend/src/utils/voice.js"],"sourcesContent":["let speechRecognition;\r\nlet listening = false;\r\nlet shouldAlwaysListen = true; // üîÅ Flag to keep mic always on\r\nlet pendingInterrupt = null;\r\n\r\nexport function initSpeechRecognition(onTranscript) {\r\n  const SpeechRecognition =\r\n    window.SpeechRecognition || window.webkitSpeechRecognition;\r\n\r\n  if (!SpeechRecognition) {\r\n    console.error(\"Speech Recognition not supported\");\r\n    return null;\r\n  }\r\n\r\n  if (!speechRecognition) {\r\n    speechRecognition = new SpeechRecognition();\r\n    speechRecognition.continuous = true;\r\n    speechRecognition.interimResults = true;\r\n    speechRecognition.lang = 'en-US';\r\n\r\n    speechRecognition.onresult = (event) => {\r\n      const transcript = Array.from(event.results)\r\n        .map(result => result[0].transcript)\r\n        .join('');\r\n      const isFinal = event.results[event.results.length - 1].isFinal;\r\n\r\n      // üß† If user interrupts the bot while it's talking\r\n      if (!isFinal && window.speechSynthesis.speaking) {\r\n        window.speechSynthesis.cancel(); // stop current speech\r\n        if (onTranscript && transcript.trim()) {\r\n          onTranscript(transcript.trim(), true); // treat as final\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (onTranscript && transcript.trim()) {\r\n        onTranscript(transcript.trim(), isFinal);\r\n      }\r\n    };\r\n\r\n    speechRecognition.onerror = (e) => {\r\n      console.error('SpeechRecognition Error:', e);\r\n      listening = false;\r\n      // üîÅ Restart on common mic failures\r\n      if (shouldAlwaysListen) {\r\n        setTimeout(() => startListening(onTranscript), 1000);\r\n      }\r\n    };\r\n\r\n    speechRecognition.onend = () => {\r\n      listening = false;\r\n      // üîÅ Restart on end (natural or forced)\r\n      if (shouldAlwaysListen) {\r\n        console.warn('SpeechRecognition ended. Restarting...');\r\n        setTimeout(() => startListening(onTranscript), 100);\r\n      }\r\n    };\r\n  }\r\n\r\n  return speechRecognition;\r\n}\r\n\r\nexport function startListening(onTranscript) {\r\n  const recognition = initSpeechRecognition(onTranscript);\r\n  if (!recognition || listening) return;\r\n\r\n  try {\r\n    recognition.start();\r\n    listening = true;\r\n    console.log('üéôÔ∏è Mic started');\r\n  } catch (err) {\r\n    console.warn('Mic start failed or already listening:', err);\r\n  }\r\n}\r\n\r\nexport function stopListening() {\r\n  shouldAlwaysListen = false; // Prevent auto-restart\r\n  if (speechRecognition && listening) {\r\n    speechRecognition.stop();\r\n    listening = false;\r\n    console.log('üõë Mic stopped manually');\r\n  }\r\n}\r\n\r\nexport function speakWithAudioFeedback(text, setVolume, onEnd, onTranscript) {\r\n  const synth = window.speechSynthesis;\r\n  if (!synth) return;\r\n\r\n  synth.cancel(); // cancel any previous voice\r\n\r\n  const utter = new SpeechSynthesisUtterance(text);\r\n  utter.lang = 'en-US';\r\n\r\n  let volInterval;\r\n\r\n  utter.onstart = () => {\r\n    volInterval = setInterval(() => {\r\n      const fakeVol = Math.random(); // Simulated volume bar\r\n      setVolume(fakeVol);\r\n    }, 100);\r\n  };\r\n\r\n  utter.onend = () => {\r\n    clearInterval(volInterval);\r\n    setVolume(0);\r\n\r\n    // üîÅ Always restart mic after speech ends\r\n    if (shouldAlwaysListen && onTranscript) {\r\n      startListening(onTranscript);\r\n    }\r\n\r\n    if (onEnd) onEnd();\r\n  };\r\n\r\n  utter.onerror = () => {\r\n    clearInterval(volInterval);\r\n    setVolume(0);\r\n\r\n    // üîÅ Restart listening on error too\r\n    if (shouldAlwaysListen && onTranscript) {\r\n      startListening(onTranscript);\r\n    }\r\n\r\n    if (onEnd) onEnd();\r\n  };\r\n\r\n  synth.speak(utter);\r\n}\r\n\r\nexport function stopSpeaking() {\r\n  if (window.speechSynthesis && window.speechSynthesis.speaking) {\r\n    window.speechSynthesis.cancel();\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}